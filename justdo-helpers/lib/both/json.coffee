_.extend JustdoHelpers,
  jsonSortify: ((jsonStringify) ->
    ###*
    * Create a “sorted” version of an object.
    *
    * JS engines internally keep track of an object's keys in the order of
    * creation time, i.e. {a:1,b:2} is treated differently from {b:2,a:1}.
    * That difference can be seen when JSON.stringify is called on that object.
    * This function normalizes any kind of object by rearranging the keys in
    * alphabetical order (numerical keys first, since v8 does so, and there's
    * nothing we can do about it).
    * @param {*} o The object to be sorted
    ###

    sortKeys = (o) ->
      if Object::toString.call(o) == '[object Object]'
        # put numeric keys first
        numeric = []
        nonNumeric = []
        Object.keys(o).forEach (key) ->
          if /^(0|[1-9][0-9]*)$/.test(key)
            numeric.push +key
          else
            nonNumeric.push key
          return
        # do the rearrangement
        return numeric.sort().concat(nonNumeric.sort()).reduce(((result, key) ->
          result[key] = sortKeys(o[key])
          # recurse!
          return result
        ), {})
      else if Array.isArray(o)
        return o.map(sortKeys)
      return o

    return (value, replacer, space) ->
      # replacer, toJSON(), cyclic references and other stuff is better handled by _native stringifier.
      # So we do JSON.stringify(sortKeys( JSON.parse(JSON.stringify()) )).
      # This approach is slightly slower but much safer than a manual stringification.
      _native = jsonStringify(value, replacer, 0)
      if !_native or _native[0] != '{' and _native[0] != '['
        # if value is not an Object or Array
        return _native
      cleanObj = JSON.parse(_native)
      return jsonStringify sortKeys(cleanObj), null, space
  )(JSON.stringify.bind(JSON))

  # ---
  # generated by js2coffee 2.2.0
  #
  # From:
  # jsonSortify = (function (jsonStringify) {

  #     /**
  #     * Create a “sorted” version of an object.
  #     *
  #     * JS engines internally keep track of an object's keys in the order of
  #     * creation time, i.e. {a:1,b:2} is treated differently from {b:2,a:1}.
  #     * That difference can be seen when JSON.stringify is called on that object.
  #     * This function normalizes any kind of object by rearranging the keys in
  #     * alphabetical order (numerical keys first, since v8 does so, and there's
  #     * nothing we can do about it).
  #     * @param {*} o The object to be sorted
  #     */
  #     var sortKeys = function (o) {
  #         if (Object.prototype.toString.call(o) === '[object Object]') {
  #             // put numeric keys first
  #             var numeric = [];
  #             var nonNumeric = [];
  #             Object.keys(o).forEach(function (key) {
  #                 if (/^(0|[1-9][0-9]*)$/.test(key)) {
  #                     numeric.push(+key);
  #                 } else {
  #                     nonNumeric.push(key);
  #                 }
  #             });
  #             // do the rearrangement
  #             return numeric.sort().concat(nonNumeric.sort()).reduce(function (result, key) {
  #                 result[key] = sortKeys(o[key]); // recurse!
  #                 return result;
  #             }, {});
  #         } else if (Array.isArray(o)) {
  #             return o.map(sortKeys);
  #         }
  #         return o;
  #     };

  #     return function (value, replacer, space) {
  #         // replacer, toJSON(), cyclic references and other stuff is better handled by _native stringifier.
  #         // So we do JSON.stringify(sortKeys( JSON.parse(JSON.stringify()) )).
  #         // This approach is slightly slower but much safer than a manual stringification.
  #         var _native = jsonStringify(value, replacer, 0);
  #         if (!_native || _native[0] !== '{' && _native[0] !== '[') { // if value is not an Object or Array
  #             return _native;
  #         }
  #         var cleanObj = JSON.parse(_native);
  #         return jsonStringify(sortKeys(cleanObj), null, space);
  #     };
  # })(JSON.stringify.bind(JSON));

  jsonComp: (x, y, options) ->
    if (exclude_fields = options?.exclude_fields)? and
        _.isArray exclude_fields
      # Make a shallow copy
      x = _.extend x
      y = _.extend y

      for field in exclude_fields
        delete x[field]
        delete y[field]

    return JustdoHelpers.jsonSortify(x) == JustdoHelpers.jsonSortify(y)

  getCircularReplacer: ->
    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value

    # Usage: JSON.stringify(circularReference, JustdoHelpers.getCircularReplacer());
    seen = new WeakSet()

    return (key, value) ->
      if typeof value == 'object' and value != null
        if seen.has(value)
          return
        seen.add value
      return value
_.extend JustdoHelpers,
  applyJustdoCommonSimpleSchemaExtensions: _.once ->
    SimpleSchema.extendOptions
      # bind_to_instance:
      #
      # Has meaning in certain contructors' options schemas under which,
      # if true will bind the given option automatically to the produced
      # instance `this'.
      # If false is ignored.
      #
      # If undefined is considered as false
      bind_to_instance: Match.Optional(Boolean)

  getCollectionSchema: (collection, options) ->
    # possible options
    #
    # options.without_keys: (Array, optional) if provided, we will exclude from
    #                       the returned SimpleSchema object the keys listed
    simple_schema = collection?.simpleSchema()

    # If no schema existed, on the collection, we can return here.
    if not simple_schema?
      return simple_schema

    # If no options provided, we can return here.
    if not options?
      return simple_schema

    if (without_keys = options.without_keys)?
      keys_to_pick = _.difference(simple_schema._schemaKeys, without_keys)

      simple_schema = simple_schema.pick keys_to_pick

    return simple_schema

  getCollectionSchemaForField: (collection, field) ->
    return collection?.simpleSchema()?._schema?[field]

  simpleSchemaCleanAndValidate: (schema, val, options) ->
    # ## Args
    #
    # schema: the schema to clean & validate val against
    #
    # val: the val to clean & validate against the schema
    #
    # options (Object, optional):
    #
    # options.throw_on_error (Boolean, optional, false by default): only if true:
    #
    #   If validation failed, will throw `Meteor.Error "invalid-options", message_string`
    #   with the validation issues as the message_string.
    #   If options.self exists and has an options.self._error function, it will be used instead of
    #   Meteor.Error.
    #
    # options.self._error (function, optional):
    #
    #   used when options.throw_on_error is true, read more in options.throw_on_error docs. 
    #
    # ## Return vals
    #
    # Returns an object with the props: {valid, validation_context, cleaned_val}
    #
    # cleaned_val: the val cleaned against the schema
    #   Note: if val is object, the clean isn't inplace cleaned_val is a new object
    # valid: true if valid false otherwise (validation is tested against the clened_val)
    # validation_context: an object with the validation context (validation is tested against the clened_val)
    #

    # simple schema clean objs in place, we prefer to avoid this behavior 
    if _.isObject val
      val = _.extend {}, val

    cleaned_val = schema.clean(val)

    validation_context = schema.newContext()

    valid = validation_context.validate(val)

    if not valid
      self = options?.self

      ik = _.map validation_context.invalidKeys(), (o) ->
        "option `#{o.name}': #{validation_context.keyErrorMessage(o.name)}"

      if self?._error?
        throw self._error "invalid-options", ik.join(";\n")
      else
        throw new Meteor.Error "invalid-options", ik.join(";\n")

    return {valid, validation_context, cleaned_val}

  loadOptionsWithSchema: (options_schema, options, conf=undefined) ->
    # Cleans and validates options using options_schema.
    # 
    # Returns the cleaned options object (new object).
    #
    # If validation failed, will throw `Meteor.Error "invalid-options", message_string`
    # with the validation issues as the message_string.
    # If conf.self exists and has an conf.self._error function, it will be used instead of
    # Meteor.Error.
    #
    # Introduce shortcuts to bind certain options automatically
    # to a Contructor's instance (if one passed in the conf.self argument).
    #
    # Arguments
    # =========
    #
    # options_schema
    # --------------
    #
    # An object with the schema for options defined for each
    # platform (both/server/client, server/client takes
    # precedence over both).
    #
    # Note, at the moment for objects that inherits from
    # constructors, it is best to ignore type checking
    # by setting type to: "skip-type-check"
    #
    # Example:
    #
    #   options_schema =
    #     both:
    #       op_a:
    #         type: "skip-type-check"
    #         optional: false
    #       op_b:
    #         type: Number
    #         optional: true
    #         defaultValue: 30
    #     client:
    #       op_c:
    #         type: Number
    #         optional: false
    #     server
    #       op_d:
    #         type: Number
    #         optional: true
    #         defaultValue: 30
    #
    # options
    # -------
    #
    # The options that will be cleaned/validated with the schema
    #
    # conf.self
    # ---------
    #
    # A reference to an object that is being generated by a constructor
    # that uses loadOptionsWithSchema to validate options received for it.
    #
    # If exists:
    # 
    #   * fields definitions in the schema that has the `bind_to_instance`
    #     option set to true will automatically be assigned to conf.self in a
    #     property whose name is the field name.
    #     Note, conf.self will be affected by this function only in this case.
    #   * If conf.self._error exists, it will be used instead of Meteor.Error to
    #     generate an error object that will be thrown for invalid options.
    #
    # conf.additional_schema
    # ----------------------
    #
    # Additional schema for `both` platform. Its fields will get
    # the least precedence vs options_schema fields.

    self = conf?.self

    @applyJustdoCommonSimpleSchemaExtensions()

    # Load, clean and validate options
    options_schema = new SimpleSchema([
      (conf?.additional_schema or {}),
      (options_schema?["both"] or {}),
      (options_schema?[JustdoHelpers.getCurrentPlatformName()] or {})
    ])

    {cleaned_val} =
      JustdoHelpers.simpleSchemaCleanAndValidate(
        options_schema,
        options,
        {self: self, throw_on_error: true}
      )
    options = cleaned_val

    if self?
      # Only if self exists, look for options that should be binded to it
      for option_name, option_def of options_schema._schema
        if option_def.bind_to_instance == true and (option_value = options[option_name])?
          self[option_name] = option_value

    return options

  getSimpleSchemaObjDefinition: (simple_schema_obj) ->
    return simple_schema_obj._schema

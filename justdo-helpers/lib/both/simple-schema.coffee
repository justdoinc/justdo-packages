_.extend JustdoHelpers,
  applyJustdoCommonSimpleSchemaExtensions: _.once ->
    SimpleSchema.extendOptions
      # bind_to_instance:
      #
      # Has meaning in certain contructors' options schemas under which,
      # if true will bind the given option automatically to the produced
      # instance `this'.
      # If false is ignored.
      #
      # If undefined is considered as false
      bind_to_instance: Match.Optional(Boolean)

  getCollectionSchema: (collection, options) ->
    # possible options
    #
    # options.without_keys: (Array, optional) if provided, we will exclude from
    #                       the returned SimpleSchema object the keys listed
    simple_schema = collection?.simpleSchema()

    # If no schema existed, on the collection, we can return here.
    if not simple_schema?
      return simple_schema

    # If no options provided, we can return here.
    if not options?
      return simple_schema

    if (without_keys = options.without_keys)?
      keys_to_pick = _.difference(simple_schema._schemaKeys, without_keys)

      simple_schema = simple_schema.pick keys_to_pick

    return simple_schema

  getCollectionSchemaForField: (collection, field) ->
    return collection?.simpleSchema()?._schema?[field]

  simpleSchemaCleanAndValidate: (schema, val, options) ->
    # ## Args
    #
    # schema: the schema to clean & validate val against
    #
    # val: the val to clean & validate against the schema
    #
    # options (Object, optional):
    #
    # options.throw_on_error (Boolean, optional, false by default): only if true:
    #
    #   If validation failed, will throw `Meteor.Error "invalid-options", message_string`
    #   with the validation issues as the message_string.
    #   If options.self exists and has an options.self._error function, it will be used instead of
    #   Meteor.Error.
    #
    # options.self._error (function, optional):
    #
    #   used when options.throw_on_error is true, read more in options.throw_on_error docs. 
    #
    # ## Return vals
    #
    # Returns an object with the props: {valid, validation_context, cleaned_val}
    #
    # cleaned_val: the val cleaned against the schema
    #   Note: if val is object, the clean isn't inplace cleaned_val is a new object
    # valid: true if valid false otherwise (validation is tested against the clened_val)
    # validation_context: an object with the validation context (validation is tested against the clened_val)
    #

    # simple schema clean objs in place, we prefer to avoid this behavior 
    if _.isObject val
      val = _.extend {}, val

    cleaned_val = schema.clean(val)

    validation_context = schema.newContext()

    valid = validation_context.validate(val)

    if not valid
      self = options?.self

      ik = _.map validation_context.invalidKeys(), (o) ->
        "option `#{o.name}': #{validation_context.keyErrorMessage(o.name)}"

      if self?._error?
        throw self._error "invalid-options", ik.join(";\n")
      else
        throw new Meteor.Error "invalid-options", ik.join(";\n")

    return {valid, validation_context, cleaned_val}

  loadOptionsWithSchema: (options_schema, options, conf=undefined) ->
    # Cleans and validates options using options_schema.
    # 
    # Returns the cleaned options object (new object).
    #
    # If validation failed, will throw `Meteor.Error "invalid-options", message_string`
    # with the validation issues as the message_string.
    # If conf.self exists and has an conf.self._error function, it will be used instead of
    # Meteor.Error.
    #
    # Introduce shortcuts to bind certain options automatically
    # to a Contructor's instance (if one passed in the conf.self argument).
    #
    # Arguments
    # =========
    #
    # options_schema
    # --------------
    #
    # An object with the schema for options defined for each
    # platform (both/server/client, server/client takes
    # precedence over both).
    #
    # Note, at the moment for objects that inherits from
    # constructors, it is best to ignore type checking
    # by setting type to: "skip-type-check"
    #
    # Example:
    #
    #   options_schema =
    #     both:
    #       op_a:
    #         type: "skip-type-check"
    #         optional: false
    #       op_b:
    #         type: Number
    #         optional: true
    #         defaultValue: 30
    #     client:
    #       op_c:
    #         type: Number
    #         optional: false
    #     server
    #       op_d:
    #         type: Number
    #         optional: true
    #         defaultValue: 30
    #
    # options
    # -------
    #
    # The options that will be cleaned/validated with the schema
    #
    # conf.self
    # ---------
    #
    # A reference to an object that is being generated by a constructor
    # that uses loadOptionsWithSchema to validate options received for it.
    #
    # If exists:
    # 
    #   * fields definitions in the schema that has the `bind_to_instance`
    #     option set to true will automatically be assigned to conf.self in a
    #     property whose name is the field name.
    #     Note, conf.self will be affected by this function only in this case.
    #   * If conf.self._error exists, it will be used instead of Meteor.Error to
    #     generate an error object that will be thrown for invalid options.
    #
    # conf.additional_schema
    # ----------------------
    #
    # Additional schema for `both` platform. Its fields will get
    # the least precedence vs options_schema fields.

    self = conf?.self

    @applyJustdoCommonSimpleSchemaExtensions()

    # Load, clean and validate options
    options_schema = new SimpleSchema([
      (conf?.additional_schema or {}),
      (options_schema?["both"] or {}),
      (options_schema?[JustdoHelpers.getCurrentPlatformName()] or {})
    ])

    {cleaned_val} =
      JustdoHelpers.simpleSchemaCleanAndValidate(
        options_schema,
        options,
        {self: self, throw_on_error: true}
      )
    options = cleaned_val

    if self?
      # Only if self exists, look for options that should be binded to it
      for option_name, option_def of options_schema._schema
        if option_def.bind_to_instance == true and (option_value = options[option_name])?
          self[option_name] = option_value

    return options

  getSimpleSchemaObjDefinition: (simple_schema_obj) ->
    return simple_schema_obj._schema

  # dependentAutoValue: (options) ->
  #   # Options should be of the form:

  #   # {
  #   #   self: # The simple schema self
  #   #   field_id: # (String) the field we define auto value for
  #     dependent_field_id: # (String) the field on which we depend
  #     autoValue: (self, dependent_field_val) -> here you can assume that security checks been done, and just process the required auto value
  #     onDependencyCleared: -> called when the dependency is cleared
  #     allow_trusted_source_forced_val: true/false # default true
  #     allow_empty_string: XXX document
  #   # }

  #   # XXX get to a point where we can write:
  #   #
  #   # autoValue: generateDependentAutoValue
  #   #   field_id: # (String) the field we define auto value for
  #   #   dependent_field_id: # (String) the field on which we depend
  #   #   autoValue: (self, dependent_field_val) -> here you can assume that security checks been done, and just process the required auto value
  #   #   onDependencyCleared: -> called when the dependency is cleared
  #   #   allow_trusted_source_forced_val: true/false # default true
  #   #   allow_empty_string: XXX document

  #   # XXX ensure that status_by works exactly as today following the change (incl. empty string)

  #   # XXX remove all the checks below
  #   check options.self, Object
  #   check options.dependent_field_id, String
  #   # autoValue has two args: self(schema obj) and dependent_field(obj)
  #   # This helper takes care of converting dependent_field_id to dependent_field obj,
  #   # so it's not necessary to call @field("dependent_field_id")
  #   check options.autoValue, Function
  #   check options.onError, Function
  #   # onDependencyCleared is triggered when the dependent_field is cleared
  #   if options.onDependencyCleared?
  #     check options.onDependencyCleared, Function
  #   if options.allow_trusted_source_forced_val?
  #     check options.allow_trusted_source_forced_val, Boolean
  #   if options.allow_empty_string?
  #     check options.allow_empty_string, Boolean

  #   # XXX Dont deconstruct the options
  #   {self, dependent_field_id, autoValue, onDependencyCleared=null, allow_trusted_source_forced_val=true, allow_empty_string=false, onError} = options

  #   # Allow changes if set from trusted source
  #   if allow_trusted_source_forced_val and self.isFromTrustedCode and self.isSet
  #     return

  #   # Empty string in an update query yields $unset operator and can bypass autovalue.
  #   # We prevent this from happening unless explicitly enabled.
  #   if not allow_empty_string and self.operator is "$unset"
  #     return self.unset()

  #   dependent_field = self.field dependent_field_id

  #   # XXX This check should be done on the first line of code of this method
  #   # right after it you can use extend to apply default.
  #   if dependent_field.isSet
  #     if onDependencyCleared? and dependent_field.value is null # XXX consider also $unset
  #       return onDependencyCleared self, dependent_field
  #     return autoValue self, dependent_field

  #   # If dependent_field isn't set and changes are made from untrusted source, reject the change.
  #   if self.isSet
  #     throw new Meteor.Error("permission-denied", "Untrusted attempt to change #{field_id} rejected", details)

  #   # We should never get to here. But just in case we do, block all updates attempted.
  #   return self.unset()

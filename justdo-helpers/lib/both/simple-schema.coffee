_.extend JustdoHelpers,
  applyJustdoCommonSimpleSchemaExtensions: _.once ->
    SimpleSchema.extendOptions
      # bind_to_instance:
      #
      # Has meaning in certain contructors' options schemas under which,
      # if true will bind the given option automatically to the produced
      # instance `this'.
      # If false is ignored.
      #
      # If undefined is considered as false
      bind_to_instance: Match.Optional(Boolean)

  getCollectionSchema: JustdoCoreHelpers.getCollectionSchema

  getCollectionSchemaForField: (collection, field) ->
    return collection?.simpleSchema()?._schema?[field]

  simpleSchemaCleanAndValidate: (schema, val, options) ->
    # ## Args
    #
    # schema: the schema to clean & validate val against
    #
    # val: the val to clean & validate against the schema
    #
    # options (Object, optional):
    #
    # options.throw_on_error (Boolean, optional, false by default): only if true:
    #
    #   If validation failed, will throw `Meteor.Error "invalid-options", message_string`
    #   with the validation issues as the message_string.
    #   If options.self exists and has an options.self._error function, it will be used instead of
    #   Meteor.Error.
    #
    # options.self._error (function, optional):
    #
    #   used when options.throw_on_error is true, read more in options.throw_on_error docs. 
    #
    # ## Return vals
    #
    # Returns an object with the props: {valid, validation_context, cleaned_val}
    #
    # cleaned_val: the val cleaned against the schema
    #   Note: if val is object, the clean isn't inplace cleaned_val is a new object
    # valid: true if valid false otherwise (validation is tested against the clened_val)
    # validation_context: an object with the validation context (validation is tested against the clened_val)
    #

    # simple schema clean objs in place, we prefer to avoid this behavior 
    if _.isObject val
      val = _.extend {}, val

    cleaned_val = schema.clean(val)

    validation_context = schema.newContext()

    valid = validation_context.validate(val)

    if not valid
      self = options?.self

      ik = _.map validation_context.invalidKeys(), (o) ->
        "option `#{o.name}': #{validation_context.keyErrorMessage(o.name)}"

      if self?._error?
        throw self._error "invalid-options", ik.join(";\n")
      else
        throw new Meteor.Error "invalid-options", ik.join(";\n")

    return {valid, validation_context, cleaned_val}

  loadOptionsWithSchema: (options_schema, options, conf=undefined) ->
    # Cleans and validates options using options_schema.
    # 
    # Returns the cleaned options object (new object).
    #
    # If validation failed, will throw `Meteor.Error "invalid-options", message_string`
    # with the validation issues as the message_string.
    # If conf.self exists and has an conf.self._error function, it will be used instead of
    # Meteor.Error.
    #
    # Introduce shortcuts to bind certain options automatically
    # to a Contructor's instance (if one passed in the conf.self argument).
    #
    # Arguments
    # =========
    #
    # options_schema
    # --------------
    #
    # An object with the schema for options defined for each
    # platform (both/server/client, server/client takes
    # precedence over both).
    #
    # Note, at the moment for objects that inherits from
    # constructors, it is best to ignore type checking
    # by setting type to: "skip-type-check"
    #
    # Example:
    #
    #   options_schema =
    #     both:
    #       op_a:
    #         type: "skip-type-check"
    #         optional: false
    #       op_b:
    #         type: Number
    #         optional: true
    #         defaultValue: 30
    #     client:
    #       op_c:
    #         type: Number
    #         optional: false
    #     server
    #       op_d:
    #         type: Number
    #         optional: true
    #         defaultValue: 30
    #
    # options
    # -------
    #
    # The options that will be cleaned/validated with the schema
    #
    # conf.self
    # ---------
    #
    # A reference to an object that is being generated by a constructor
    # that uses loadOptionsWithSchema to validate options received for it.
    #
    # If exists:
    # 
    #   * fields definitions in the schema that has the `bind_to_instance`
    #     option set to true will automatically be assigned to conf.self in a
    #     property whose name is the field name.
    #     Note, conf.self will be affected by this function only in this case.
    #   * If conf.self._error exists, it will be used instead of Meteor.Error to
    #     generate an error object that will be thrown for invalid options.
    #
    # conf.additional_schema
    # ----------------------
    #
    # Additional schema for `both` platform. Its fields will get
    # the least precedence vs options_schema fields.

    self = conf?.self

    @applyJustdoCommonSimpleSchemaExtensions()

    # Load, clean and validate options
    options_schema = new SimpleSchema([
      (conf?.additional_schema or {}),
      (options_schema?["both"] or {}),
      (options_schema?[JustdoHelpers.getCurrentPlatformName()] or {})
    ])

    {cleaned_val} =
      JustdoHelpers.simpleSchemaCleanAndValidate(
        options_schema,
        options,
        {self: self, throw_on_error: true}
      )
    options = cleaned_val

    if self?
      # Only if self exists, look for options that should be binded to it
      for option_name, option_def of options_schema._schema
        if option_def.bind_to_instance == true and (option_value = options[option_name])?
          self[option_name] = option_value

    return options

  getSimpleSchemaObjDefinition: (simple_schema_obj) ->
    return simple_schema_obj._schema

  generateDependentAutoValue: (options) ->
    # Supported options:
    #
    #   field_id: # (String) the field we define auto value for
    #   dependent_field_id: # (String) the field on which we depend
    #   autoValue: (self, dependent_field_val) -> here you can assume that security checks been done, and just process the required auto value
    #   onDependencyCleared: -> called when the dependency is cleared ($set to null or $unset)
    #   allow_trusted_source_forced_val: true/false # default true
    #   allow_empty_string: true/false, allow this field to be unset by updating with empty string "" # default false
    #
    # Usage example:
    #
    # Schema =
    #   jdr_type:
    #     label: "Risk/Issue"
    #     type: String
    #     optional: true
    #     allowedValues: [null, "risk", "issue"]

    #   jdr_triggered_date:
    #     label: "Triggered On"
    #     type: Date
    #     optional: true
    #     autoValue: JustdoHelpers.generateDependentAutoValue({
    #       field_id: "jdr_triggered_date"
    #       dependent_field_id: "jdr_type"
    #       autoValue: (self, dependent_field_val) ->
    #         if dependent_field_val is "issue"
    #           return new Date
    #         return
    #       })

    if not (allow_trusted_source_forced_val = options.allow_trusted_source_forced_val)?
      allow_trusted_source_forced_val = true

    if not (allow_empty_string = options.allow_empty_string)?
      allow_empty_string = false

    return ->
      if Meteor.isClient
        return
      
      # Allow changes if set from trusted source
      if allow_trusted_source_forced_val and @isFromTrustedCode and @isSet
        return

      # Empty string in an update query yields $unset operator and can bypass autovalue.
      # We prevent this from happening unless explicitly enabled.
      if not allow_empty_string and @operator is "$unset"
        return @unset()

      dependent_field = @field options.dependent_field_id

      if dependent_field.isSet
        if options.onDependencyCleared? and (dependent_field.value is null or dependent_field.operator is "$unset")
          return options.onDependencyCleared @, dependent_field.value
        return options.autoValue @, dependent_field.value

      # If dependent_field isn't set and changes are made from untrusted source, reject the change.
      if @isSet
        throw new Meteor.Error("permission-denied", "Untrusted attempt to change #{options.field_id} rejected")

      # We should never get to here. But just in case we do, block all updates attempted.
      return @unset()
